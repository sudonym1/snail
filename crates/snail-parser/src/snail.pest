// Top-level program entry points
program = { SOI ~ stmt_sep* ~ program_entry_list? ~ stmt_sep* ~ EOI }
awk_program = { SOI ~ stmt_sep* ~ awk_entry_list? ~ stmt_sep* ~ EOI }
map_program = { SOI ~ stmt_sep* ~ map_entry_list? ~ stmt_sep* ~ EOI }

// Regular mode: program with optional BEGIN/END blocks
program_entry_list = { program_entry ~ (stmt_sep* ~ program_entry)* ~ stmt_sep* }
program_entry = { program_begin_end | stmt }
program_begin_end = _{ program_begin | program_end }
program_begin = { "BEGIN" ~ block }
program_end = { "END" ~ block }

// AWK mode: pattern-action rules
awk_entry_list = { awk_entry ~ (stmt_sep* ~ awk_entry)* ~ stmt_sep* }
awk_entry = _{ awk_begin | awk_end | awk_rule }
awk_begin = { "BEGIN" ~ block }
awk_end = { "END" ~ block }
awk_rule = { block | awk_pattern ~ block? }
awk_pattern = { expr }

// Map mode: program with optional BEGIN/END blocks
map_entry_list = { map_entry ~ (stmt_sep* ~ map_entry)* ~ stmt_sep* }
map_entry = { map_begin_end | stmt }
map_begin_end = _{ map_begin | map_end }
map_begin = { "BEGIN" ~ block }
map_end = { "END" ~ block }

// Statements: separated by semicolons or newlines
// Compound statements (ending with }) don't need trailing separators
// Simple statements need separators unless they're the last statement
stmt_list = { stmt_item* ~ final_stmt? }
stmt_item = _{ compound_stmt ~ stmt_sep* | simple_stmt ~ stmt_sep+ }
final_stmt = _{ compound_stmt | simple_stmt }
stmt_sep = _{ ";" ~ NEWLINE* | NEWLINE+ }
line_cont = _{ NEWLINE* }

stmt = _{ compound_stmt | simple_stmt }

compound_stmt = _{ if_stmt | while_stmt | for_stmt | def_stmt | class_stmt | try_stmt | with_stmt }
simple_stmt = _{
  return_stmt
  | break_stmt
  | continue_stmt
  | pass_stmt
  | raise_stmt
  | assert_stmt
  | del_stmt
  | import_stmt
  | assign_stmt
  | expr_stmt
}

// Braced block of statements
block = { "{" ~ stmt_sep* ~ stmt_list? ~ stmt_sep* ~ "}" }

// Control flow: if/elif/else, while/else, for/else
if_stmt = { "if" ~ line_cont ~ if_cond ~ line_cont ~ block ~ (stmt_sep* ~ "elif" ~ line_cont ~ if_cond ~ line_cont ~ block)* ~ (stmt_sep* ~ "else" ~ line_cont ~ block)? }
while_stmt = { "while" ~ line_cont ~ while_cond ~ line_cont ~ block ~ (stmt_sep* ~ "else" ~ line_cont ~ block)? }
for_stmt = { "for" ~ line_cont ~ assign_target_list ~ line_cont ~ "in" ~ line_cont ~ expr ~ line_cont ~ block ~ (stmt_sep* ~ "else" ~ line_cont ~ block)? }
if_cond = { let_cond | expr }
while_cond = { let_cond | expr }
let_cond = { "let" ~ line_cont ~ assign_target_list ~ line_cont ~ "=" ~ line_cont ~ expr ~ line_cont ~ let_guard? }
let_guard = { ";" ~ line_cont ~ expr }

// Function and class definitions
def_stmt = { "def" ~ line_cont ~ identifier ~ line_cont ~ parameters? ~ line_cont ~ block }
class_stmt = { "class" ~ line_cont ~ identifier ~ line_cont ~ block }

// Exception handling: try/except/else/finally
try_stmt = { "try" ~ line_cont ~ block ~ (try_except_tail | try_finally_tail) }
try_except_tail = _{ (stmt_sep* ~ except_clause)+ ~ (stmt_sep* ~ else_clause)? ~ (stmt_sep* ~ finally_clause)? }
try_finally_tail = _{ stmt_sep* ~ finally_clause }
except_clause = { "except" ~ line_cont ~ (expr ~ (line_cont ~ "as" ~ line_cont ~ identifier)?)? ~ line_cont ~ block }
else_clause = { "else" ~ line_cont ~ block }
finally_clause = { "finally" ~ line_cont ~ block }

// Context managers
with_stmt = { "with" ~ line_cont ~ with_items ~ line_cont ~ block }
with_items = { with_item ~ (line_cont ~ "," ~ line_cont ~ with_item)* }
with_item = { expr ~ (line_cont ~ "as" ~ line_cont ~ assign_target)? }

// Function parameters: regular, *args, **kwargs
parameters = { "(" ~ line_cont ~ param_list? ~ line_cont ~ ")" }
param_list = { parameter ~ (line_cont ~ "," ~ line_cont ~ parameter)* ~ (line_cont ~ ",")? }
parameter = _{ regular_param | star_param | kw_param }
regular_param = { identifier ~ (line_cont ~ "=" ~ line_cont ~ expr)? }
star_param = { "*" ~ identifier }
kw_param = { "**" ~ identifier }

// Simple statements
return_stmt = { "return" ~ line_cont ~ expr? }
raise_stmt = { "raise" ~ line_cont ~ expr? ~ (line_cont ~ "from" ~ line_cont ~ expr)? }
assert_stmt = { "assert" ~ line_cont ~ expr ~ (line_cont ~ "," ~ line_cont ~ expr)? }
del_stmt = { "del" ~ line_cont ~ assign_target ~ (line_cont ~ "," ~ line_cont ~ assign_target)* }
break_stmt = { "break" }
continue_stmt = { "continue" }
pass_stmt = { "pass" }

// Import statements: from/import and import
import_stmt = _{ import_from | import_names }
import_from = { "from" ~ line_cont ~ import_from_module ~ line_cont ~ "import" ~ line_cont ~ import_from_items }
import_names = { "import" ~ line_cont ~ import_items }
import_from_module = { relative_module | dotted_name }
relative_module = { relative_dots ~ dotted_name? }
relative_dots = { "."+ }
import_from_items = { import_star | import_paren_items | import_items }
import_items = { import_item ~ (line_cont ~ "," ~ line_cont ~ import_item)* }
import_items_multiline = { import_item ~ (NEWLINE* ~ "," ~ NEWLINE* ~ import_item)* }
import_paren_items = { "(" ~ NEWLINE* ~ import_items_multiline ~ NEWLINE* ~ ","? ~ NEWLINE* ~ ")" }
import_star = { "*" }
import_item = { dotted_name ~ (line_cont ~ "as" ~ line_cont ~ identifier)? }
dotted_name = { identifier ~ ("." ~ identifier)* }

// Assignment and expression statements
assign_stmt = { assign_target_list ~ "=" ~ line_cont ~ expr }
assign_target_list = { assign_target_tuple | assign_target }
assign_target_tuple = { assign_target_item ~ line_cont ~ "," ~ line_cont ~ (assign_target_item ~ (line_cont ~ "," ~ line_cont ~ assign_target_item)* ~ (line_cont ~ ",")?)? }
assign_target_item = _{ assign_target_star | assign_target }
assign_target_star = { "*" ~ assign_target }
assign_target = _{ assign_target_ref | assign_list | assign_tuple }
assign_target_ref = { assign_target_atom ~ ((line_cont ~ attribute) | index)* }
assign_target_atom = { identifier | "(" ~ line_cont ~ assign_target_ref ~ line_cont ~ ")" }
assign_list = { "[" ~ line_cont ~ assign_target_items? ~ line_cont ~ "]" }
assign_target_items = { assign_target_item ~ (line_cont ~ "," ~ line_cont ~ assign_target_item)* ~ (line_cont ~ ",")? }
assign_tuple = { "(" ~ line_cont ~ assign_target_tuple ~ line_cont ~ ")" }
expr_stmt = { expr }

// Expressions: precedence from lowest (aug assignment) to highest (power)
expr = { aug_assign_expr | yield_expr | if_expr }

yield_expr = { "yield" ~ (yield_from | yield_value)? }
yield_from = { "from" ~ if_expr }
yield_value = _{ if_expr }

aug_assign_expr = { aug_target ~ aug_op ~ line_cont ~ expr }
aug_target = { assign_target_ref }
aug_op = { "+=" | "-=" | "**=" | "*=" | "//=" | "/=" | "%=" }

// Compact try operator: expr? or expr:fallback?
try_suffix = { try_fallback? ~ "?" }
try_fallback = { ":" ~ try_fallback_unary }

// Fallback expression grammar (mirrors unary/power/primary but without try_suffix)
try_fallback_unary = { ((prefix_incr | unary_op) ~ line_cont)* ~ try_fallback_power }
try_fallback_power = { try_fallback_primary ~ (line_cont ~ pow_op ~ line_cont ~ try_fallback_primary)* }
try_fallback_primary = { atom ~ (call | (line_cont ~ attribute) | index | postfix_incr)* }

// Ternary conditional
if_expr = { or_expr ~ (line_cont ~ "if" ~ line_cont ~ or_expr ~ line_cont ~ "else" ~ line_cont ~ if_expr)? }

// Boolean operators
or_expr = { and_expr ~ (line_cont ~ "or" ~ line_cont ~ and_expr)* }
and_expr = { not_expr ~ (line_cont ~ "and" ~ line_cont ~ not_expr)* }
not_expr = { (not_op ~ line_cont ~ not_expr) | pipeline }
not_op = @{ "not" ~ !ident_continue }

// Pipeline operator
pipeline = { comparison ~ (line_cont ~ pipe_op ~ line_cont ~ comparison)* }
pipe_op = _{ "|" }

// Comparisons
comparison = { sum ~ (line_cont ~ comp_op ~ line_cont ~ sum)* }
comp_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" | comp_kw_not ~ comp_kw_in | comp_kw_is ~ comp_kw_not | comp_kw_in | comp_kw_is }
comp_kw_not = @{ "not" ~ !ident_continue }
comp_kw_in = @{ "in" ~ !ident_continue }
comp_kw_is = @{ "is" ~ !ident_continue }

// Arithmetic operators
sum = { product ~ (line_cont ~ add_op ~ line_cont ~ product)* }
add_op = @{ "+" ~ !"+" | "-" ~ !"-" }
product = { unary ~ (line_cont ~ mul_op ~ line_cont ~ unary)* }
mul_op = { "//" | "*" | "/" | "%" }
unary = { ((prefix_incr | unary_op) ~ line_cont)* ~ power }
unary_op = { "+" | "-" }
prefix_incr = { "++" | "--" }
power = { primary ~ (line_cont ~ pow_op ~ line_cont ~ primary)* }
pow_op = { "**" }

// Primary expressions: atoms with postfix operations
primary = { atom ~ (call | (line_cont ~ attribute) | index | try_suffix | postfix_incr)* }
postfix_incr = { "++" | "--" }

// Function calls with positional, keyword, *args, **kwargs
call = { "(" ~ line_cont ~ (argument ~ (line_cont ~ "," ~ line_cont ~ argument)*)? ~ line_cont ~ ")" }
argument = { kw_argument | star_argument | expr }
kw_argument = { identifier ~ line_cont ~ "=" ~ line_cont ~ expr }
star_argument = _{ kw_star_arg | star_arg }
star_arg = { "*" ~ line_cont ~ expr }
kw_star_arg = { "**" ~ line_cont ~ expr }

// Attribute access and indexing/slicing
attribute = { "." ~ line_cont ~ (identifier | attribute_index) }
attribute_index = @{ ASCII_DIGIT+ }
index = { "[" ~ line_cont ~ slice ~ line_cont ~ "]" }
slice = { slice_expr | expr }
slice_expr = { slice_start? ~ line_cont ~ ":" ~ line_cont ~ slice_end? }
slice_start = { expr }
slice_end = { expr }

// Atomic expressions: literals, variables, collections, etc.
atom = _{
  literal
  | def_expr
  | regex
  | subprocess
  | structured_accessor
  | exception_var
  | field_index_var
  | injected_var
  | placeholder
  | identifier
  | list_comp
  | list_literal
  | set_literal
  | dict_comp
  | dict_literal
  | tuple_literal
  | compound_expr
  | paren_expr
}

def_expr = { "def" ~ line_cont ~ parameters? ~ line_cont ~ block }

// Parenthesized expression (preserved in AST for proper validation)
paren_expr = { "(" ~ line_cont ~ expr ~ line_cont ~ ")" }

// Compound expression: multiple semicolon-separated expressions in parens
compound_expr = { "(" ~ NEWLINE* ~ expr ~ (";" ~ NEWLINE* ~ expr)+ ~ NEWLINE* ~ ";"? ~ ")" }

// Subprocess invocation: $(cmd) captures output, @(cmd) captures exit status
subprocess = { subprocess_capture | subprocess_status }
subprocess_capture = { "$(" ~ subprocess_body ~ ")" }
subprocess_status = { "@(" ~ subprocess_body ~ ")" }
subprocess_body = { subprocess_part* }
subprocess_part = _{ subprocess_brace_block | subprocess_text }
subprocess_brace_block = { "{" ~ subprocess_brace_content* ~ "}" }
subprocess_brace_content = _{ subprocess_brace_block | (!"}" ~ !"{" ~ ANY) }
subprocess_text = @{ ( "{{" | "}}" | (!("{" | ")") ~ ANY) )+ }

// Structured pipeline accessor: $[query] for querying structured data
// The query is treated as a raw string (no interpolation)
structured_accessor = { "$[" ~ structured_query_body ~ "]" }
structured_query_body = @{ structured_query_part* }
structured_query_part = _{ "[" ~ structured_query_body ~ "]" | (!"[" ~ !"]" ~ ANY) }

// Collection literals and comprehensions
tuple_literal = {
  "(" ~ line_cont ~ ")"
  | "(" ~ line_cont ~ expr ~ line_cont ~ "," ~ line_cont ~ (expr ~ (line_cont ~ "," ~ line_cont ~ expr)* ~ (line_cont ~ ",")?)? ~ line_cont ~ ")"
}
list_comp = { "[" ~ line_cont ~ expr ~ line_cont ~ comp_for ~ line_cont ~ "]" }
list_literal = { "[" ~ line_cont ~ (expr ~ (line_cont ~ "," ~ line_cont ~ expr)*)? ~ line_cont ~ "]" }
set_literal = { "#{" ~ line_cont ~ (expr ~ (line_cont ~ "," ~ line_cont ~ expr)*)? ~ line_cont ~ "}" }
dict_comp = { "%{" ~ line_cont ~ expr ~ line_cont ~ ":" ~ line_cont ~ expr ~ line_cont ~ comp_for ~ line_cont ~ "}" }
dict_literal = { "%{" ~ line_cont ~ (dict_entry ~ (line_cont ~ "," ~ line_cont ~ dict_entry)*)? ~ line_cont ~ "}" }
dict_entry = { expr ~ line_cont ~ ":" ~ line_cont ~ expr }

// Comprehension clauses
comp_for = { "for" ~ line_cont ~ identifier ~ line_cont ~ "in" ~ line_cont ~ expr ~ (line_cont ~ comp_if)* }
comp_if = { "if" ~ line_cont ~ expr }

// Literals: numbers, strings, booleans, None
literal = { number | string | boolean | none }
boolean = { "True" | "False" }
none = { "None" }

// Special variables: exception, AWK fields, map vars, injected vars
exception_var = { "$e" ~ !ident_continue }
field_index_var = @{ "$" ~ ASCII_DIGIT+ }
injected_var = { "$text" | "$src" | "$env" | "$fn" | "$fd" | "$n" | "$m" | "$f" }

// Number, string, and regex literals
number = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
string = @{ string_prefix? ~ (triple_double | triple_single | double_string | single_string) }
string_prefix = { byte_raw_prefix | raw_byte_prefix | byte_prefix | raw_prefix }
byte_raw_prefix = { "br" }
raw_byte_prefix = { "rb" }
byte_prefix = { "b" }
raw_prefix = { "r" }
triple_double = { "\"\"\"" ~ (!"\"\"\"" ~ ANY)* ~ "\"\"\"" }
triple_single = { "'''" ~ (!"'''" ~ ANY)* ~ "'''" }
double_string = { "\"" ~ double_string_content ~ "\"" }
double_string_content = @{ (brace_block | escaped_char | double_string_char)* }
single_string = { "'" ~ single_string_content ~ "'" }
single_string_content = @{ (brace_block | escaped_char | single_string_char)* }
brace_block = { "{" ~ brace_content* ~ "}" }
brace_content = _{ brace_block | (!"}" ~ !"{" ~ ANY) }
escaped_char = { "\\" ~ ANY }
double_string_char = { (!("\\" | "\"" | "{") ~ ANY) }
single_string_char = { (!("\\" | "'" | "{") ~ ANY) }
regex = @{ "/" ~ ( "\\/" | !"/" ~ ANY )* ~ "/" }

// Placeholder for pipeline insertion
placeholder = { "_" ~ !ident_continue }

// Identifiers: must not be keywords
identifier = @{ !keyword ~ ident_start ~ ident_continue* }
ident_start = { ASCII_ALPHA | "_" }
ident_continue = { ASCII_ALPHANUMERIC | "_" }
keyword = _{
  ("if" | "else" | "elif" | "while" | "for" | "in" | "def" | "class"
  | "return" | "break" | "continue" | "pass" | "raise" | "try" | "except"
  | "finally" | "with" | "assert" | "del" | "and" | "or" | "not" | "import" | "from" | "as"
  | "yield"
  | "let"
  | "BEGIN" | "END"
  | "True" | "False" | "None") ~ !ident_continue
}

// Lexical rules: whitespace, newlines, comments
WHITESPACE = _{ " " | "\t" }
NEWLINE = _{ "\r\n" | "\n" }
COMMENT = _{ "#" ~ !"{" ~ (!NEWLINE ~ ANY)* }
