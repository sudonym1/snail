// Top-level program entry points
program = { SOI ~ stmt_sep* ~ stmt_list? ~ stmt_sep* ~ EOI }
awk_program = { SOI ~ stmt_sep* ~ awk_entry_list? ~ stmt_sep* ~ EOI }
map_program = { SOI ~ stmt_sep* ~ map_entry_list? ~ stmt_sep* ~ EOI }

// AWK mode: pattern-action rules
awk_entry_list = { awk_entry ~ (stmt_sep* ~ awk_entry)* ~ stmt_sep* }
awk_entry = _{ awk_begin | awk_end | awk_rule }
awk_begin = { "BEGIN" ~ block }
awk_end = { "END" ~ block }
awk_rule = { block | awk_pattern ~ block? }
awk_pattern = { expr }

// Map mode: program with optional BEGIN/END blocks
map_entry_list = { map_entry ~ (stmt_sep* ~ map_entry)* ~ stmt_sep* }
map_entry = { map_begin_end | stmt }
map_begin_end = _{ map_begin | map_end }
map_begin = { "BEGIN" ~ block }
map_end = { "END" ~ block }

// Statements: separated by semicolons or newlines
// Compound statements (ending with }) don't need trailing separators
// Simple statements need separators unless they're the last statement
stmt_list = { stmt_item* ~ final_stmt? }
stmt_item = _{ compound_stmt ~ stmt_sep* | simple_stmt ~ stmt_sep+ }
final_stmt = _{ compound_stmt | simple_stmt }
stmt_sep = _{ ";" ~ NEWLINE* | NEWLINE+ }

stmt = _{ compound_stmt | simple_stmt }

compound_stmt = _{ if_stmt | while_stmt | for_stmt | def_stmt | class_stmt | try_stmt | with_stmt }
simple_stmt = _{
  return_stmt
  | break_stmt
  | continue_stmt
  | pass_stmt
  | raise_stmt
  | assert_stmt
  | del_stmt
  | import_stmt
  | assign_stmt
  | expr_stmt
}

// Braced block of statements
block = { "{" ~ stmt_sep* ~ stmt_list? ~ stmt_sep* ~ "}" }

// Control flow: if/elif/else, while/else, for/else
if_stmt = { "if" ~ if_cond ~ block ~ (stmt_sep* ~ "elif" ~ if_cond ~ block)* ~ (stmt_sep* ~ "else" ~ block)? }
while_stmt = { "while" ~ while_cond ~ block ~ (stmt_sep* ~ "else" ~ block)? }
for_stmt = { "for" ~ assign_target_list ~ "in" ~ expr ~ block ~ (stmt_sep* ~ "else" ~ block)? }
if_cond = { let_cond | expr }
while_cond = { let_cond | expr }
let_cond = { "let" ~ assign_target_list ~ "=" ~ expr ~ let_guard? }
let_guard = { ";" ~ expr }

// Function and class definitions
def_stmt = { "def" ~ identifier ~ parameters? ~ block }
class_stmt = { "class" ~ identifier ~ block }

// Exception handling: try/except/else/finally
try_stmt = { "try" ~ block ~ (try_except_tail | try_finally_tail) }
try_except_tail = _{ (stmt_sep* ~ except_clause)+ ~ (stmt_sep* ~ else_clause)? ~ (stmt_sep* ~ finally_clause)? }
try_finally_tail = _{ stmt_sep* ~ finally_clause }
except_clause = { "except" ~ (expr ~ ("as" ~ identifier)?)? ~ block }
else_clause = { "else" ~ block }
finally_clause = { "finally" ~ block }

// Context managers
with_stmt = { "with" ~ with_items ~ block }
with_items = { with_item ~ ("," ~ with_item)* }
with_item = { expr ~ ("as" ~ assign_target)? }

// Function parameters: regular, *args, **kwargs
parameters = { "(" ~ param_list? ~ ")" }
param_list = { parameter ~ ("," ~ parameter)* ~ ","? }
parameter = _{ regular_param | star_param | kw_param }
regular_param = { identifier ~ ("=" ~ expr)? }
star_param = { "*" ~ identifier }
kw_param = { "**" ~ identifier }

// Simple statements
return_stmt = { "return" ~ expr? }
raise_stmt = { "raise" ~ expr? ~ ("from" ~ expr)? }
assert_stmt = { "assert" ~ expr ~ ("," ~ expr)? }
del_stmt = { "del" ~ assign_target ~ ("," ~ assign_target)* }
break_stmt = { "break" }
continue_stmt = { "continue" }
pass_stmt = { "pass" }

// Import statements: from/import and import
import_stmt = _{ import_from | import_names }
import_from = { "from" ~ import_from_module ~ "import" ~ import_from_items }
import_names = { "import" ~ import_items }
import_from_module = { relative_module | dotted_name }
relative_module = { relative_dots ~ dotted_name? }
relative_dots = { "."+ }
import_from_items = { import_star | import_paren_items | import_items }
import_items = { import_item ~ ("," ~ import_item)* }
import_items_multiline = { import_item ~ (NEWLINE* ~ "," ~ NEWLINE* ~ import_item)* }
import_paren_items = { "(" ~ NEWLINE* ~ import_items_multiline ~ NEWLINE* ~ ","? ~ NEWLINE* ~ ")" }
import_star = { "*" }
import_item = { dotted_name ~ ("as" ~ identifier)? }
dotted_name = { identifier ~ ("." ~ identifier)* }

// Assignment and expression statements
assign_stmt = { assign_target_list ~ "=" ~ expr }
assign_target_list = { assign_target_tuple | assign_target }
assign_target_tuple = { assign_target_item ~ "," ~ (assign_target_item ~ ("," ~ assign_target_item)* ~ ","?)? }
assign_target_item = _{ assign_target_star | assign_target }
assign_target_star = { "*" ~ assign_target }
assign_target = _{ assign_target_ref | assign_list | assign_tuple }
assign_target_ref = { assign_target_atom ~ (attribute | index)* }
assign_target_atom = { identifier | "(" ~ assign_target_ref ~ ")" }
assign_list = { "[" ~ assign_target_items? ~ "]" }
assign_target_items = { assign_target_item ~ ("," ~ assign_target_item)* ~ ","? }
assign_tuple = { "(" ~ assign_target_tuple ~ ")" }
expr_stmt = { expr }

// Expressions: precedence from lowest (aug assignment) to highest (power)
expr = { aug_assign_expr | yield_expr | if_expr }

yield_expr = { "yield" ~ (yield_from | yield_value)? }
yield_from = { "from" ~ if_expr }
yield_value = _{ if_expr }

aug_assign_expr = { aug_target ~ aug_op ~ expr }
aug_target = { assign_target_ref }
aug_op = { "+=" | "-=" | "**=" | "*=" | "//=" | "/=" | "%=" }

// Compact try operator: expr? or expr:fallback?
try_suffix = { try_fallback? ~ "?" }
try_fallback = { ":" ~ try_fallback_unary }

// Fallback expression grammar (mirrors unary/power/primary but without try_suffix)
try_fallback_unary = { (prefix_incr | unary_op)* ~ try_fallback_power }
try_fallback_power = { try_fallback_primary ~ (pow_op ~ try_fallback_primary)* }
try_fallback_primary = { atom ~ (call | attribute | index | postfix_incr)* }

// Ternary conditional
if_expr = { or_expr ~ ("if" ~ or_expr ~ "else" ~ if_expr)? }

// Boolean operators
or_expr = { and_expr ~ ("or" ~ and_expr)* }
and_expr = { not_expr ~ ("and" ~ not_expr)* }
not_expr = { (not_op ~ not_expr) | pipeline }
not_op = { "not" }

// Pipeline operator
pipeline = { comparison ~ (pipe_op ~ comparison)* }
pipe_op = _{ "|" }

// Comparisons
comparison = { sum ~ (comp_op ~ sum)* }
comp_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" | "not" ~ "in" | "is" ~ "not" | "in" | "is" }

// Arithmetic operators
sum = { product ~ (add_op ~ product)* }
add_op = { "+" | "-" }
product = { unary ~ (mul_op ~ unary)* }
mul_op = { "//" | "*" | "/" | "%" }
unary = { (prefix_incr | unary_op)* ~ power }
unary_op = { "+" | "-" }
prefix_incr = { "++" | "--" }
power = { primary ~ (pow_op ~ primary)* }
pow_op = { "**" }

// Primary expressions: atoms with postfix operations
primary = { atom ~ (call | attribute | index | try_suffix | postfix_incr)* }
postfix_incr = { "++" | "--" }

// Function calls with positional, keyword, *args, **kwargs
call = { "(" ~ (argument ~ ("," ~ argument)*)? ~ ")" }
argument = { kw_argument | star_argument | expr }
kw_argument = { identifier ~ "=" ~ expr }
star_argument = _{ kw_star_arg | star_arg }
star_arg = { "*" ~ expr }
kw_star_arg = { "**" ~ expr }

// Attribute access and indexing/slicing
attribute = { "." ~ (identifier | attribute_index) }
attribute_index = @{ ASCII_DIGIT+ }
index = { "[" ~ slice ~ "]" }
slice = { slice_expr | expr }
slice_expr = { slice_start? ~ ":" ~ slice_end? }
slice_start = { expr }
slice_end = { expr }

// Atomic expressions: literals, variables, collections, etc.
atom = _{
  literal
  | def_expr
  | regex
  | subprocess
  | structured_accessor
  | exception_var
  | field_index_var
  | injected_var
  | placeholder
  | identifier
  | list_comp
  | list_literal
  | set_literal
  | dict_comp
  | dict_literal
  | tuple_literal
  | compound_expr
  | paren_expr
}

def_expr = { "def" ~ parameters? ~ block }

// Parenthesized expression (preserved in AST for proper validation)
paren_expr = { "(" ~ expr ~ ")" }

// Compound expression: multiple semicolon-separated expressions in parens
compound_expr = { "(" ~ NEWLINE* ~ expr ~ (";" ~ NEWLINE* ~ expr)+ ~ NEWLINE* ~ ";"? ~ ")" }

// Subprocess invocation: $(cmd) captures output, @(cmd) captures exit status
subprocess = { subprocess_capture | subprocess_status }
subprocess_capture = { "$(" ~ subprocess_body ~ ")" }
subprocess_status = { "@(" ~ subprocess_body ~ ")" }
subprocess_body = { subprocess_part* }
subprocess_part = _{ subprocess_expr | subprocess_text }
subprocess_expr = { "{" ~ expr ~ "}" }
subprocess_text = @{ ( "{{" | "}}" | (!("{" | ")") ~ ANY) )+ }

// Structured pipeline accessor: $[query] for querying structured data
// The query is treated as a raw string (no interpolation)
structured_accessor = { "$[" ~ structured_query_body ~ "]" }
structured_query_body = @{ structured_query_part* }
structured_query_part = _{ "[" ~ structured_query_body ~ "]" | (!"[" ~ !"]" ~ ANY) }

// Collection literals and comprehensions
tuple_literal = { "(" ~ ")" | "(" ~ expr ~ "," ~ (expr ~ ("," ~ expr)* ~ ","?)? ~ ")" }
list_comp = { "[" ~ expr ~ comp_for ~ "]" }
list_literal = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }
set_literal = { "#{" ~ (expr ~ ("," ~ expr)*)? ~ "}" }
dict_comp = { "%{" ~ expr ~ ":" ~ expr ~ comp_for ~ "}" }
dict_literal = { "%{" ~ (dict_entry ~ ("," ~ dict_entry)*)? ~ "}" }
dict_entry = { expr ~ ":" ~ expr }

// Comprehension clauses
comp_for = { "for" ~ identifier ~ "in" ~ expr ~ comp_if* }
comp_if = { "if" ~ expr }

// Literals: numbers, strings, booleans, None
literal = { number | string | boolean | none }
boolean = { "True" | "False" }
none = { "None" }

// Special variables: exception, AWK fields, map vars, injected vars
exception_var = { "$e" }
field_index_var = @{ "$" ~ ASCII_DIGIT+ }
injected_var = { "$text" | "$src" | "$fn" | "$fd" | "$n" | "$p" | "$m" | "$f" }

// Number, string, and regex literals
number = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
string = @{ string_prefix? ~ (triple_double | triple_single | double_string | single_string) }
string_prefix = { byte_raw_prefix | raw_byte_prefix | byte_prefix | raw_prefix }
byte_raw_prefix = { "br" }
raw_byte_prefix = { "rb" }
byte_prefix = { "b" }
raw_prefix = { "r" }
triple_double = { "\"\"\"" ~ (!"\"\"\"" ~ ANY)* ~ "\"\"\"" }
triple_single = { "'''" ~ (!"'''" ~ ANY)* ~ "'''" }
double_string = { "\"" ~ double_string_content ~ "\"" }
double_string_content = @{ (brace_block | escaped_char | double_string_char)* }
single_string = { "'" ~ single_string_content ~ "'" }
single_string_content = @{ (brace_block | escaped_char | single_string_char)* }
brace_block = { "{" ~ brace_content* ~ "}" }
brace_content = _{ brace_block | (!"}" ~ !"{" ~ ANY) }
escaped_char = { "\\" ~ ANY }
double_string_char = { (!("\\" | "\"" | "{") ~ ANY) }
single_string_char = { (!("\\" | "'" | "{") ~ ANY) }
regex = @{ "/" ~ ( "\\/" | !"/" ~ ANY )* ~ "/" }

// Placeholder for pipeline insertion
placeholder = { "_" ~ !ident_continue }

// Identifiers: must not be keywords
identifier = @{ !keyword ~ ident_start ~ ident_continue* }
ident_start = { ASCII_ALPHA | "_" }
ident_continue = { ASCII_ALPHANUMERIC | "_" }
keyword = _{
  ("if" | "else" | "elif" | "while" | "for" | "in" | "def" | "class"
  | "return" | "break" | "continue" | "pass" | "raise" | "try" | "except"
  | "finally" | "with" | "assert" | "del" | "and" | "or" | "not" | "import" | "from" | "as"
  | "yield"
  | "let"
  | "BEGIN" | "END"
  | "True" | "False" | "None") ~ !ident_continue
}

// Lexical rules: whitespace, newlines, comments
WHITESPACE = _{ " " | "\t" }
NEWLINE = _{ "\r\n" | "\n" }
COMMENT = _{ "#" ~ !"{" ~ (!NEWLINE ~ ANY)* }
