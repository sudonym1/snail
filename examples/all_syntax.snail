# Example Snail program exercising all supported syntax.
# Each section includes comments to highlight the syntax being demonstrated.
from __future__ import braces

# ---- Imports (regular, aliased, from-import, and relative imports) ----
import math, sys as sysmod
from math import sqrt as root

# Import variants from a real module so the example exercises them at runtime.
sysmod.path.insert(0, "examples")
from snail_import_demo import (
    ANSWER as demo_answer,
    greet as demo_greet,
)
from snail_import_demo import *;
print("import demo", demo_answer, demo_greet("snail"), NAME)

# Relative imports (exercise a real package under examples).
import snail_relpkg
import snail_relpkg.subpkg
__package__ = "snail_relpkg"
from . import relmod
__package__ = "snail_relpkg.subpkg"
from .. import relmod as parent_relmod
from . import submod
print("relative import", relmod.REL_VALUE, parent_relmod.REL_VALUE, submod.SUB_VALUE)

# ---- Classes, methods, and context managers ----
class Counter {
    def __init__(self, start) {
        self.start = start
    }
    def inc(self, step) {
        value = self.start + step
        return value
    }
}

class SimpleCtx {
    def __enter__(self) { # this is a { }
        return "context"
    }

    def __exit__(self, exc_type, exc, tb) {
        return False
    }
}

# ---- Function definitions, implicit returns, and argument forms ----
def compute(nums) {
    total = 0
    for n in nums {
        if n % 2 == 0 {
            total = total + n
        } elif n < 0 {
            continue
        } else {
            pass
        }
    }
    return total
}

def named_args(head, tail) {
    print("named args", head, tail)
}

named_args(head=1, tail=2)
# Statement terminator with semicolon
named_args(1, 2);

# Implicit return (last expression) vs. explicit suppression with semicolon
# (implicit return is used by auto-printing in the CLI)
def add(a, b) {
    a + b
}

def add_suppressed(a, b) {
    a + b;
}

print("implicit return", add(1, 2))
print("implicit return suppressed", add_suppressed(1, 2))

# Default args, *args, **kwargs
# (note: space after * is allowed in Snail)
def join_all(head, tail=0, * rest, **extras) {
    total = head + tail
    for n in rest {
        total = total + n
    }
    if "bonus" in extras {
        total = total + extras["bonus"]
    }
    return total
}

def risky {
    return 1
}

def cleanup() {
    pass
}

# Generators and yield-from

def count_up(limit) {
    i = 0
    while i < limit {
        yield i
        i = i + 1
    }
}

def chained_count() {
    yield from count_up(2)
    yield 99
}

# Function expressions (inline def)
adder = def(x, y) { x + y }
scaled = def(value) { doubled = value * 2; doubled + 1 }
adder_result = adder(2, 3)
scaled_result = scaled(4)

# ---- Collections, destructuring, and comprehension ----
nums = [1, 2, 3, 4]
data = list(range(5))
pairs = %{"a": 1, "b": 2}
ids = #{1, 2, 3}
empty_ids = #{}
pair = (1, 2)
single = (1,)
empty = ()
coords = (3, 4)
x, y = coords
first_val, *rest_vals = [1, 2, 3]
evens = [n for n in nums if n % 2 == 0]
lookup = %{n: n * 2 for n in nums if n > 1}

# Slicing
first = data[0]
mid = data[1:3]
head = data[:2]
tail = data[2:]

# ---- String and byte literal variants + interpolation ----
raw_text = r"raw\\ntext"
multi_text = """line one
line two"""
raw_multi = r"""raw\\nline
raw line two"""
# Byte strings (including raw and triple-quoted forms)
byte_text = b"hello bytes"
byte_single = b'single quoted bytes'
raw_byte = rb"\n is literal"
raw_byte_alt = br"\t is also literal"
byte_multi = b"""multi
line bytes"""
# Byte strings WITH interpolation (unlike Python!)
byte_name = "world"
byte_interp = b"hello {byte_name}"
# String interpolation, escaped braces
user_name = "snail"
greeting = "hello {user_name}"
brace_text = "brace {{ok}}"

# ---- Subprocess and pipeline syntax ----
cmd_name = "snail"
# $(...) captures stdout
# @(...) returns SnailExitStatus (raise on non-zero, with ? to swallow)
echoed = $(echo {cmd_name})
try {
    echoed = $(__snail_missing_command__)? # it is required to provide a default value for this form.
} except Exception as e {
    echoed = $(__snail_missing_command__):"default"?
}
assert echoed == "default"
status_ok = @(echo ready)
status_fail = @(__snail_missing_command__)?
assert status_ok
assert status_ok.rc == 0
assert not status_fail
assert status_fail.rc != 0
assert status_fail == status_fail.rc

# Subprocess pipelines and placeholder arguments
piped = "test" | $(more)
assert piped == "test"
chained = "b\na" | $(sort) | $(more)
assert chained == "a\nb"

def greet(name, suffix) { return "Hello {name}{suffix}" }
placeholder_first = "World" | greet(_, "!")
assert placeholder_first == "Hello World!"
placeholder_second = "World" | greet("Hello ", _)
assert placeholder_second == "Hello Hello World"
placeholder_named = "World" | greet("Hello ", suffix=_)
assert placeholder_named == "Hello Hello World"

# ---- Glob expansion with path() ----
glob_files = path("*.toml")
assert type(glob_files) == list
assert len(glob_files) > 0

# Fallback on no matches
glob_empty = path("*.zzz_nonexistent_ext")?
assert glob_empty == []

# Multiple patterns
glob_multi = path("*.toml", "*.lock")
assert len(glob_multi) >= 1

# ---- Operators, ternary, and precedence ----
missing = None
flag = not False and True or False
is_none = missing is None
has_two = 2 in data
fallback = "yes" if flag else "no"
power = -2 ** 3
mix = (1 + 2) * 3 - 4 / 2 + 5 % 2 + 7 // 2

# ---- Pre/post increment/decrement and augmented assignment ----
counter_val = 0
pre_counter = ++counter_val
post_counter = counter_val++
aug_counter = (counter_val += 3)

counter_obj = Counter(0)
pre_attr = ++counter_obj.start
post_attr = counter_obj.start++
aug_attr = (counter_obj.start += 2)

scratch = [10]
pre_idx = ++scratch[0]
post_idx = scratch[0]++
aug_idx = (scratch[0] += 4)

# ---- Control flow (if/elif/else, loops, continue/break/pass) ----
counter = Counter(10)
value = counter.inc(5)
root_val = root(16)
pi = math.pi

i = 0
loop_done = False
while i < 4 {
    try {
        if i == 1 {
            i = i + 1
            continue
        } elif i == 2 {
            break
        }
    } finally { cleanup() }
    i = i + 1
} else {
    loop_done = True
}

# Regex pattern binding + guard in if-let
if let [user, domain] = "user@example.com" in /^([\w.]+)@([\w.]+)$/; user {
    print(domain)
}

# while-let loop (binding optional value)
def next_pair(items, idx) {
    if idx < len(items) { return items[idx] }
    return None
}

pair_items = [[1, 2], [3, 4]]
pair_idx = 0
while let [left, right] = next_pair(pair_items, pair_idx) {
    pair_idx = pair_idx + 1
}

for_done = False
for n in nums {
    try { if n < 0 { break } } finally { cleanup() }
} else {
    for_done = True
}

# ---- try/except/else/finally, raise, and exception chaining ----
try { raise ValueError("boom") }
except ValueError as err { handled = True }
except { handled = False }
else { ok = True }
finally { cleanup() }

try { risky() }
finally { cleanup() }

try { raise ValueError("bad") }
except ValueError as err {
        try { raise RuntimeError("wrapped") from err }
except { pass }
}

def boom() {
    raise ValueError("boom")
}

# ---- Compact try operator (expr?) with fallback and $e ----
safe_value = risky()?
safe_fallback = risky():$e?
safe_details = risky():$e.args[0]?
tight_sum = 1 + boom():5?
tight_arg = boom():$e?.args[0]
tight_name = boom():$e?.__class__.__name__
tight_fallback_boundary = boom():0? + 1

# ---- Regex literals and matching ----
text = "abc123"
regex_match = text in /abc(\d+)/
compiled_regex = /abc(\d+)/
compiled_match = compiled_regex.search(text)
# Match groups: $m.1 maps to $m[1] (inside lines { } blocks)

# ---- Exception fallback hooks and compound expressions ----
def fallback_handler() {
    return "dunder"
}

def risky_fallback() {
    err = Exception("boom")
    err.__fallback__ = fallback_handler
    raise err
}

prefer_lambda = risky_fallback():"lambda"?
dunder_only = risky_fallback()?
# Compound expression (stmt1; stmt2; expr)
compound_value = (counter.inc(1); counter.inc(2); counter.inc(3))
compound_recovered = (risky_fallback(); counter.inc(4)):"rescued"?
compound_swallowed = (risky_fallback(); counter.inc(5))?

# ---- Environment variables ----
os.environ["SNAIL_DEMO"] = "ok"
env_attr = $env.SNAIL_DEMO
env_index = $env["SNAIL_DEMO"]
env_missing = $env.SNAIL_MISSING?

# ---- with statement ----
with SimpleCtx() as message { ctx_msg = message }

# ---- Calls, unpacking, and iteration ----
total = compute(data)
extras = %{"bonus": 5}
values = [3, 4]
joined = join_all(1, 2, *values, **extras)

# for-in loop over generator
gen_values = []
for v in chained_count() {
    gen_values.append(v)
}

# ---- Structured pipeline accessor with JSON ----
# js() parses immediately and returns a queryable object
json_obj = js(r'{"users": [{"name": "Alice"}, {"name": "Bob"}]}')
first_name = json_obj | $[users[0].name]
assert first_name == "Alice"

# Can also inline the js() call
names = js(r'{"users": [{"name": "Alice"}, {"name": "Bob"}]}') | $[users[*].name]
assert names == ["Alice", "Bob"]

# Simple extraction
simple = js(r'{"foo": 12}') | $[foo]
assert simple == 12

print("structured pipeline", first_name, names, simple)

# ---- Auto-imports ----
# Auto-import: sys, os, and Path are available without explicit import
# (sys is also explicitly imported above as sysmod for demonstration)
auto_sys_version = sys.version_info.major
auto_os_name = os.name
auto_path_cwd = Path(".").resolve()
print("auto-import sys.version_info.major", auto_sys_version)
print("auto-import os.name", auto_os_name)
print("auto-import Path", auto_path_cwd)

# ---- Output / asserts ----
assert total == 6, "total"
assert byte_text == b"hello bytes"
assert byte_interp == b"hello world"
assert len(raw_byte) == 13  # rb"\n is literal" = 13 chars as bytes
print("first", first)
print("value", value)
print("root", root_val)
print("pi", pi)
print("flags", flag, is_none, has_two)
print("fallback", fallback)
print("power", power)
print("mix", mix)
print("greeting", greeting)
print("brace_text", brace_text)
print("total", total)
print("evens", evens)
print("lookup", lookup)
print("with", ctx_msg)
print("joined", joined)
print("gen_values", gen_values)
print("adder_result", adder_result)
print("scaled_result", scaled_result)
print("loop_done", loop_done)
print("for_done", for_done)
print("pair", pair)
print("first_val", first_val)
print("rest_vals", rest_vals)
print("single", single)
print("empty", empty)
print("mid", mid)
print("head", head)
print("tail", tail)
print("safe_value", safe_value)
print("safe_fallback", safe_fallback)
print("safe_details", safe_details)
print("regex", regex_match[1], compiled_match[1])
print("echoed", echoed)
print("status_ok", status_ok)
print("status_fail", status_fail)
print("prefer_lambda", prefer_lambda)
print("dunder_only", dunder_only)
print("compound_value", compound_value)
print("compound_recovered", compound_recovered)
print("compound_swallowed", compound_swallowed)

# del statement
# (demonstrates deleting a name)
temp_value = 42
del temp_value

# Pipeline to callables
class Doubler {
    def __call__(self, x) {
        return x * 2
    }
}

pipeline_result = 21 | Doubler()
print("pipeline_result", pipeline_result)

info = "default to f-strings"
print("strings {info}", raw_text, multi_text, raw_multi)
value = 3.14159
width = 6
prec = 2
print("format {value:.2f}", "nested {value:{width}.{prec}f}", "repr {info!r}")
print("byte strings", byte_text, byte_single, raw_byte, raw_byte_alt)
print("byte interp", byte_interp)
print(sysmod.version)

# ---- Lines and Files blocks (inline awk/map) ----
# lines { } processes lines from stdin or a source
import tempfile
temp = tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False)
temp.write("hello world\nfoo bar\nbaz qux\n")
temp.close()

line_count = 0
lines(temp.name) {
    line_count += 1
}
assert line_count == 3, "lines counted"
print("lines count", line_count)

# Pattern/action inside lines
found = []
lines(temp.name) {
    /hello/ { found.append($0) }
}
assert found == ["hello world"], "pattern/action match"
print("lines pattern found", found)

# Multi-file lines: $fn resets per file, $src tracks path
temp2 = tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False)
temp2.write("extra line\n")
temp2.close()
multi_srcs = []
lines(temp.name, temp2.name) {
    multi_srcs.append(str($fn) + ":" + $src)
}

# Lines/files with call argument syntax: *args, **kwargs, keyword args
src_list = [temp.name, temp2.name]
star_count = 0
lines(*src_list) {
    star_count += 1
}
assert star_count == 4, "lines *args counted"
print("lines *args count", star_count)
assert multi_srcs[0].endswith(temp.name.split("/")[-1])
assert multi_srcs[-1].endswith(temp2.name.split("/")[-1])
print("lines multi-source", len(multi_srcs))

# Files block with source expression
file_sizes = []
files([temp.name]) {
    file_sizes.append(len(str($text)))
}
assert len(file_sizes) == 1
print("files text size", file_sizes)

# Multi-file files: comma-separated sources
multi_file_srcs = []
files(temp.name, temp2.name) {
    multi_file_srcs.append($src)
}
assert len(multi_file_srcs) == 2
print("files multi-source", len(multi_file_srcs))

# Lines with sep kwarg (field separator)
sep_fields = []
temp3 = tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False)
temp3.write("a/b/c\n")
temp3.close()
lines(temp3.name, sep="/") {
    sep_fields.append($1)
}
assert sep_fields == ["a"], "lines sep kwarg"
print("lines sep kwarg", sep_fields)

# Lines with sep + ws kwargs (field separator with whitespace)
ws_fields = []
temp4 = tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False)
temp4.write("x y/z\n")
temp4.close()
lines(temp4.name, sep="/", ws=True) {
    ws_fields.append(str(len($f)))
}
assert ws_fields == ["3"], "lines sep+ws kwargs"
print("lines sep+ws kwargs", ws_fields)

os.unlink(temp3.name)
os.unlink(temp4.name)

os.unlink(temp.name)

# The implicit return of the last non-semicolon expression is pretty printed
# to stdout, unless -P is specified
"automatically printed"
