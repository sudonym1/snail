# Example Snail program exercising all supported syntax.
import math, sys as sysmod
from math import sqrt as root
from __future__ import braces

if False {
    # Import variants (guarded to avoid runtime errors in this example script).
    from . import local_mod
    from ..pkg import name as alias
    from math import *
    from math import (
        sin,
        cos,
    )
}

class Counter {
    def __init__(self, start) {
        self.start = start
    }
    def inc(self, step) {
        value = self.start + step
        return value
    }
}

class SimpleCtx {
    def __enter__(self) {
        return "context"
    }

    def __exit__(self, exc_type, exc, tb) {
        return False
    }
}

def compute(nums) {
    total = 0
    for n in nums {
        if n % 2 == 0 {
            total = total + n
        } elif n < 0 {
            continue
        } else {
            pass
        }
    }
    return total
}

def named_args(head, tail) {
    print("named args", head, tail)
}

named_args(head=1,  tail=2)

named_args(1,2);

def join_all(head, tail=0, * rest, **extras) {
    total = head + tail
    for n in rest {
        total = total + n
    }
    if "bonus" in extras {
        total = total + extras["bonus"]
    }
    return total
}

def risky() {
    return 1
}

def cleanup() {
    pass
}

data = list(range(5))
nums = [1, 2, 3, 4]
pairs = {"a": 1, "b": 2}
pair = (1, 2)
single = (1,)
empty = ()
coords = (3, 4)
x, y = coords
first_val, *rest_vals = [1, 2, 3]
evens = [n for n in nums if n % 2 == 0]
lookup = {n: n * 2 for n in nums if n > 1}
raw_text = r"raw\\ntext"
multi_text = """line one
line two"""
raw_multi = r"""raw\\nline
raw line two"""
# Byte strings
byte_text = b"hello bytes"
byte_single = b'single quoted bytes'
raw_byte = rb"\n is literal"
raw_byte_alt = br"\t is also literal"
byte_multi = b"""multi
line bytes"""
# Byte strings WITH interpolation (unlike Python!)
byte_name = "world"
byte_interp = b"hello {byte_name}"
user_name = "snail"
greeting = "hello {user_name}"
brace_text = "brace {{ok}}"
cmd_name = "snail"
echoed = $(echo {cmd_name})
try {
    echoed = $(false)? # it is required to provide a default value for this form.
} except Exception as e {
    echoed = $(false):"default"?
}
assert echoed == "default"
status_ok = @(echo ready)
status_fail = @(false)?
# Subprocess pipelines
piped = "test" | $(cat)
assert piped == "test"
chained = "a\nb" | $(grep a) | $(cat)
assert chained == "a"
def greet(name, suffix) { return "Hello {name}{suffix}" }
placeholder_first = "World" | greet(_, "!")
assert placeholder_first == "Hello World!"
placeholder_second = "World" | greet("Hello ", _)
assert placeholder_second == "Hello Hello World"
placeholder_named = "World" | greet("Hello ", suffix=_)
assert placeholder_named == "Hello Hello World"
first = data[0]
mid = data[1:3]
head = data[:2]
tail = data[2:]
missing = None
flag = not False and True or False
is_none = missing is None
has_two = 2 in data
fallback = "yes" if flag else "no"
power = -2 ** 3
mix = (1 + 2) * 3 - 4 / 2 + 5 % 2 + 7 // 2

counter_val = 0
pre_counter = ++counter_val
post_counter = counter_val++
aug_counter = (counter_val += 3)
counter_obj = Counter(0)
pre_attr = ++counter_obj.start
post_attr = counter_obj.start++
aug_attr = (counter_obj.start += 2)
scratch = [10]
pre_idx = ++scratch[0]
post_idx = scratch[0]++
aug_idx = (scratch[0] += 4)

counter = Counter(10)
value = counter.inc(5)
root_val = root(16)
pi = math.pi

i = 0
loop_done = False
while i < 4 {
    try {
        if i == 1 {
            i = i + 1
            continue
        } elif i == 2 {
            break
        }
    } finally { cleanup() }
    i = i + 1
} else {
    loop_done = True
}

if let [user, domain] = "user@example.com" in /^([\w.]+)@([\w.]+)$/; user {
    print(domain)
}

def next_pair(items, idx) {
    if idx < len(items) { return items[idx] }
    return None
}

pair_items = [[1, 2], [3, 4]]
pair_idx = 0
while let [left, right] = next_pair(pair_items, pair_idx) {
    pair_idx = pair_idx + 1
}

for_done = False
for n in nums {
    try { if n < 0 { break } } finally { cleanup() }
} else {
    for_done = True
}

try { raise ValueError("boom") }
except ValueError as err { handled = True }
except { handled = False }
else { ok = True }
finally { cleanup() }

try { risky() }
finally { cleanup() }

try { raise ValueError("bad") }
except ValueError as err {
        try { raise RuntimeError("wrapped") from err }
except { pass }
}

def boom() {
    raise ValueError("boom")
}

safe_value = risky()?
safe_fallback = risky():$e?
safe_details = risky():$e.args[0]?
tight_sum = 1 + boom():5?
tight_arg = boom():$e?.args[0]
tight_name = boom():$e?.__class__.__name__
tight_fallback_boundary = boom():0? + 1
text = "abc123"
regex_match = text in /abc(\d+)/
compiled_regex = /abc(\d+)/
compiled_match = compiled_regex.search(text)
# Awk mode match groups: $m.1 maps to $m[1]
# Awk/map begin/end blocks: BEGIN { ... } / END { ... }

def fallback_handler() {
    return "dunder"
}

def risky_fallback() {
    err = Exception("boom")
    err.__fallback__ = fallback_handler
    raise err
}

prefer_lambda = risky_fallback():"lambda"?
dunder_only = risky_fallback()?
compound_value = (counter.inc(1); counter.inc(2); counter.inc(3))
compound_recovered = (risky_fallback(); counter.inc(4)):"rescued"?
compound_swallowed = (risky_fallback(); counter.inc(5))?

with SimpleCtx() as message { ctx_msg = message }

total = compute(data)
extras = {"bonus": 5}
values = [3, 4]
joined = join_all(1, 2, *values, **extras)
assert total == 6, "total"
print("first", first)
print("value", value)
print("root", root_val)
print("pi", pi)
print("flags", flag, is_none, has_two)
print("fallback", fallback)
print("power", power)
print("mix", mix)
print("greeting", greeting)
print("brace_text", brace_text)
print("total", total)
print("evens", evens)
print("lookup", lookup)
print("with", ctx_msg)
print("joined", joined)
print("loop_done", loop_done)
print("for_done", for_done)
print("pair", pair)
print("first_val", first_val)
print("rest_vals", rest_vals)
print("single", single)
print("empty", empty)
print("mid", mid)
print("head", head)
print("tail", tail)
print("safe_value", safe_value)
print("safe_fallback", safe_fallback)
print("safe_details", safe_details)
print("regex", regex_match[1], compiled_match[1])
print("echoed", echoed)
print("status_ok", status_ok)
print("status_fail", status_fail)
print("prefer_lambda", prefer_lambda)
print("dunder_only", dunder_only)
print("compound_value", compound_value)
print("compound_recovered", compound_recovered)
print("compound_swallowed", compound_swallowed)
temp_value = 42
del temp_value

class Doubler {
    def __call__(self, x) {
        return x * 2
    }
}
pipeline_result = 21 | Doubler()
print("pipeline_result", pipeline_result)

# Structured pipeline accessor with JSON
# js() parses immediately and returns a queryable object
json_obj = js(r'{"users": [{"name": "Alice"}, {"name": "Bob"}]}')
first_name = json_obj | $[users[0].name]
assert first_name == "Alice"

# Can also inline the js() call
names = js(r'{"users": [{"name": "Alice"}, {"name": "Bob"}]}') | $[users[*].name]
assert names == ["Alice", "Bob"]

# Simple extraction
simple = js(r'{"foo": 12}') | $[foo]
assert simple == 12

print("structured pipeline", first_name, names, simple)

# Auto-import: sys, os, and Path are available without explicit import
# (sys is also explicitly imported above as sysmod for demonstration)
auto_sys_version = sys.version_info.major
auto_os_name = os.name
auto_path_cwd = Path(".").resolve()
print("auto-import sys.version_info.major", auto_sys_version)
print("auto-import os.name", auto_os_name)
print("auto-import Path", auto_path_cwd)

info = "default to f-strings"
print("strings {info}", raw_text, multi_text, raw_multi)
print("byte strings", byte_text, byte_single, raw_byte, raw_byte_alt)
print("byte interp", byte_interp)
assert byte_text == b"hello bytes"
assert byte_interp == b"hello world"
assert len(raw_byte) == 13  # rb"\n is literal" = 13 chars as bytes
print(sysmod.version)

# The last expression is always pretty printed to stdout, unless -P is specified
"automatically printed"
