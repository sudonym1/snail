program = { SOI ~ stmt_sep* ~ stmt_list? ~ stmt_sep* ~ EOI }
awk_program = { SOI ~ stmt_sep* ~ awk_entry_list? ~ stmt_sep* ~ EOI }
awk_entry_list = { awk_entry ~ (stmt_sep* ~ awk_entry)* ~ stmt_sep* }
awk_entry = _{ awk_begin | awk_end | awk_rule }
awk_begin = { "BEGIN" ~ block }
awk_end = { "END" ~ block }
awk_rule = { block | awk_pattern ~ block? }
awk_pattern = { expr }

stmt_list = { stmt ~ (stmt_sep ~ stmt)* ~ stmt_sep? }
stmt_sep = _{ ";" ~ NEWLINE* | NEWLINE+ }

stmt = _{ compound_stmt | simple_stmt }

compound_stmt = _{ if_stmt | while_stmt | for_stmt | def_stmt | class_stmt | try_stmt | with_stmt }
simple_stmt = _{
  return_stmt
  | break_stmt
  | continue_stmt
  | pass_stmt
  | raise_stmt
  | assert_stmt
  | del_stmt
  | import_stmt
  | assign_stmt
  | expr_stmt
}

block = { "{" ~ stmt_sep* ~ stmt_list? ~ stmt_sep* ~ "}" }

if_stmt = { "if" ~ expr ~ block ~ (stmt_sep* ~ "elif" ~ expr ~ block)* ~ (stmt_sep* ~ "else" ~ block)? }
while_stmt = { "while" ~ expr ~ block ~ (stmt_sep* ~ "else" ~ block)? }
for_stmt = { "for" ~ identifier ~ "in" ~ expr ~ block ~ (stmt_sep* ~ "else" ~ block)? }
def_stmt = { "def" ~ identifier ~ parameters ~ block }
class_stmt = { "class" ~ identifier ~ block }
try_stmt = { "try" ~ block ~ (try_except_tail | try_finally_tail) }
try_except_tail = _{ (stmt_sep* ~ except_clause)+ ~ (stmt_sep* ~ else_clause)? ~ (stmt_sep* ~ finally_clause)? }
try_finally_tail = _{ stmt_sep* ~ finally_clause }
except_clause = { "except" ~ (expr ~ ("as" ~ identifier)?)? ~ block }
else_clause = { "else" ~ block }
finally_clause = { "finally" ~ block }
with_stmt = { "with" ~ with_items ~ block }
with_items = { with_item ~ ("," ~ with_item)* }
with_item = { expr ~ ("as" ~ assign_target)? }

parameters = { "(" ~ param_list? ~ ")" }
param_list = { parameter ~ ("," ~ parameter)* ~ ","? }
parameter = _{ regular_param | star_param | kw_param }
regular_param = { identifier ~ ("=" ~ expr)? }
star_param = { "*" ~ identifier }
kw_param = { "**" ~ identifier }

return_stmt = { "return" ~ expr? }
raise_stmt = { "raise" ~ expr? ~ ("from" ~ expr)? }
assert_stmt = { "assert" ~ expr ~ ("," ~ expr)? }
del_stmt = { "del" ~ assign_target ~ ("," ~ assign_target)* }
break_stmt = { "break" }
continue_stmt = { "continue" }
pass_stmt = { "pass" }

import_stmt = _{ import_from | import_names }
import_from = { "from" ~ dotted_name ~ "import" ~ import_items }
import_names = { "import" ~ import_items }
import_items = { import_item ~ ("," ~ import_item)* }
import_item = { dotted_name ~ ("as" ~ identifier)? }
dotted_name = { identifier ~ ("." ~ identifier)* }

assign_stmt = { assign_target ~ "=" ~ expr }
assign_target = { identifier ~ (attribute | index)* }
expr_stmt = { expr }

expr = { if_expr }
try_suffix = { "?" ~ (!add_op ~ try_fallback)? }
try_fallback = { unary }
if_expr = { or_expr ~ ("if" ~ or_expr ~ "else" ~ if_expr)? }
or_expr = { and_expr ~ ("or" ~ and_expr)* }
and_expr = { not_expr ~ ("and" ~ not_expr)* }
not_expr = { (not_op ~ not_expr) | comparison }
not_op = { "not" }
comparison = { sum ~ (comp_op ~ sum)* }
comp_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" | "in" | "is" }

sum = { product ~ (add_op ~ product)* }
add_op = { "+" | "-" }
product = { unary ~ (mul_op ~ unary)* }
mul_op = { "//" | "*" | "/" | "%" }
unary = { unary_op* ~ power }
unary_op = { "+" | "-" }
power = { primary ~ (pow_op ~ primary)* }
pow_op = { "**" }

primary = { atom ~ (call | attribute | index | try_suffix)* }
call = { "(" ~ (argument ~ ("," ~ argument)*)? ~ ")" }
argument = { kw_argument | star_argument | expr }
kw_argument = { identifier ~ "=" ~ expr }
star_argument = _{ kw_star_arg | star_arg }
star_arg = { "*" ~ expr }
kw_star_arg = { "**" ~ expr }
attribute = { "." ~ identifier }
index = { "[" ~ slice ~ "]" }
slice = { slice_expr | expr }
slice_expr = { slice_start? ~ ":" ~ slice_end? }
slice_start = { expr }
slice_end = { expr }

atom = _{
  literal
  | regex
  | subprocess
  | exception_var
  | field_index_var
  | injected_var
  | identifier
  | list_comp
  | list_literal
  | dict_comp
  | dict_literal
  | set_literal
  | tuple_literal
  | compound_expr
  | "(" ~ expr ~ ")"
}

compound_expr = { "(" ~ NEWLINE* ~ expr ~ (";" ~ NEWLINE* ~ expr)+ ~ NEWLINE* ~ ";"? ~ ")" }

subprocess = { subprocess_capture | subprocess_status }
subprocess_capture = { "$(" ~ subprocess_body ~ ")" }
subprocess_status = { "@(" ~ subprocess_body ~ ")" }
subprocess_body = { subprocess_part* }
subprocess_part = _{ subprocess_expr | subprocess_text }
subprocess_expr = { "{" ~ expr ~ "}" }
subprocess_text = @{ ( "{{" | "}}" | (!("{" | ")") ~ ANY) )+ }

tuple_literal = { "(" ~ ")" | "(" ~ expr ~ "," ~ (expr ~ ("," ~ expr)* ~ ","?)? ~ ")" }
list_comp = { "[" ~ expr ~ comp_for ~ "]" }
list_literal = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }
dict_comp = { "{" ~ expr ~ ":" ~ expr ~ comp_for ~ "}" }
dict_literal = { "{" ~ (dict_entry ~ ("," ~ dict_entry)*)? ~ "}" }
set_literal = { "{" ~ expr ~ ("," ~ expr)* ~ ","? ~ "}" }
dict_entry = { expr ~ ":" ~ expr }

comp_for = { "for" ~ identifier ~ "in" ~ expr ~ comp_if* }
comp_if = { "if" ~ expr }
literal = { number | string | boolean | none }
boolean = { "True" | "False" }
none = { "None" }
exception_var = { "$e" }
field_index_var = @{ "$" ~ ASCII_DIGIT+ }
injected_var = { "$fn" | "$l" | "$f" | "$n" | "$p" | "$m" }
number = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
string = @{ raw_prefix? ~ (triple_double | triple_single | double_string | single_string) }
raw_prefix = { "r" }
triple_double = { "\"\"\"" ~ (!"\"\"\"" ~ ANY)* ~ "\"\"\"" }
triple_single = { "'''" ~ (!"'''" ~ ANY)* ~ "'''" }
double_string = { "\"" ~ ( "\\\"" | !"\"" ~ ANY )* ~ "\"" }
single_string = { "'" ~ ( "\\'" | !"'" ~ ANY )* ~ "'" }
regex = @{ "/" ~ ( "\\/" | !"/" ~ ANY )* ~ "/" }

identifier = @{ !keyword ~ ident_start ~ ident_continue* }
ident_start = { ASCII_ALPHA | "_" }
ident_continue = { ASCII_ALPHANUMERIC | "_" }
keyword = _{
  ("if" | "else" | "elif" | "while" | "for" | "in" | "def" | "class"
  | "return" | "break" | "continue" | "pass" | "raise" | "try" | "except"
  | "finally" | "with" | "assert" | "del" | "and" | "or" | "not" | "import" | "from" | "as"
  | "True" | "False" | "None") ~ !ident_continue
}

WHITESPACE = _{ " " | "\t" }
NEWLINE = _{ "\r\n" | "\n" }
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }
