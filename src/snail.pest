program = { SOI ~ stmt_sep* ~ stmt_list? ~ stmt_sep* ~ EOI }

stmt_list = { stmt ~ (stmt_sep ~ stmt)* ~ stmt_sep? }
stmt_sep = _{ ";" | NEWLINE+ }

stmt = _{ compound_stmt | simple_stmt }

compound_stmt = _{ if_stmt | while_stmt | for_stmt | def_stmt | class_stmt | try_stmt | with_stmt }
simple_stmt = _{
  return_stmt
  | break_stmt
  | continue_stmt
  | pass_stmt
  | raise_stmt
  | import_stmt
  | assign_stmt
  | expr_stmt
}

block = { "{" ~ stmt_sep* ~ stmt_list? ~ stmt_sep* ~ "}" }

if_stmt = { "if" ~ expr ~ block ~ (stmt_sep* ~ "elif" ~ expr ~ block)* ~ (stmt_sep* ~ "else" ~ block)? }
while_stmt = { "while" ~ expr ~ block }
for_stmt = { "for" ~ identifier ~ "in" ~ expr ~ block }
def_stmt = { "def" ~ identifier ~ parameters ~ block }
class_stmt = { "class" ~ identifier ~ block }
try_stmt = { "try" ~ block ~ (try_except_tail | try_finally_tail) }
try_except_tail = _{ (stmt_sep* ~ except_clause)+ ~ (stmt_sep* ~ else_clause)? ~ (stmt_sep* ~ finally_clause)? }
try_finally_tail = _{ stmt_sep* ~ finally_clause }
except_clause = { "except" ~ (expr ~ ("as" ~ identifier)?)? ~ block }
else_clause = { "else" ~ block }
finally_clause = { "finally" ~ block }
with_stmt = { "with" ~ with_items ~ block }
with_items = { with_item ~ ("," ~ with_item)* }
with_item = { expr ~ ("as" ~ assign_target)? }

parameters = { "(" ~ (identifier ~ ("," ~ identifier)*)? ~ ")" }

return_stmt = { "return" ~ expr? }
raise_stmt = { "raise" ~ expr? ~ ("from" ~ expr)? }
break_stmt = { "break" }
continue_stmt = { "continue" }
pass_stmt = { "pass" }

import_stmt = _{ import_from | import_names }
import_from = { "from" ~ dotted_name ~ "import" ~ import_items }
import_names = { "import" ~ import_items }
import_items = { import_item ~ ("," ~ import_item)* }
import_item = { dotted_name ~ ("as" ~ identifier)? }
dotted_name = { identifier ~ ("." ~ identifier)* }

assign_stmt = { assign_target ~ "=" ~ expr }
assign_target = { identifier ~ (attribute | index)* }
expr_stmt = { expr }

expr = { or_expr }
or_expr = { and_expr ~ ("or" ~ and_expr)* }
and_expr = { not_expr ~ ("and" ~ not_expr)* }
not_expr = { (not_op ~ not_expr) | comparison }
not_op = { "not" }
comparison = { sum ~ (comp_op ~ sum)* }
comp_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" | "in" | "is" }

sum = { product ~ (add_op ~ product)* }
add_op = { "+" | "-" }
product = { unary ~ (mul_op ~ unary)* }
mul_op = { "//" | "*" | "/" | "%" }
unary = { unary_op* ~ power }
unary_op = { "+" | "-" }
power = { primary ~ (pow_op ~ primary)* }
pow_op = { "**" }

primary = { atom ~ (call | attribute | index)* }
call = { "(" ~ (argument ~ ("," ~ argument)*)? ~ ")" }
argument = { identifier ~ "=" ~ expr | expr }
attribute = { "." ~ identifier }
index = { "[" ~ expr ~ "]" }

atom = _{
  literal
  | identifier
  | list_comp
  | list_literal
  | dict_comp
  | dict_literal
  | "(" ~ expr ~ ")"
}

list_comp = { "[" ~ expr ~ comp_for ~ "]" }
list_literal = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }
dict_comp = { "{" ~ expr ~ ":" ~ expr ~ comp_for ~ "}" }
dict_literal = { "{" ~ (dict_entry ~ ("," ~ dict_entry)*)? ~ "}" }
dict_entry = { expr ~ ":" ~ expr }

comp_for = { "for" ~ identifier ~ "in" ~ expr ~ comp_if* }
comp_if = { "if" ~ expr }
literal = { number | string | boolean | none }
boolean = { "True" | "False" }
none = { "None" }
number = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
string = @{ raw_prefix? ~ (triple_double | triple_single | double_string | single_string) }
raw_prefix = { "r" }
triple_double = { "\"\"\"" ~ (!"\"\"\"" ~ ANY)* ~ "\"\"\"" }
triple_single = { "'''" ~ (!"'''" ~ ANY)* ~ "'''" }
double_string = { "\"" ~ ( "\\\"" | !"\"" ~ ANY )* ~ "\"" }
single_string = { "'" ~ ( "\\'" | !"'" ~ ANY )* ~ "'" }

identifier = @{ !keyword ~ ident_start ~ ident_continue* }
ident_start = { ASCII_ALPHA | "_" }
ident_continue = { ASCII_ALPHANUMERIC | "_" }
keyword = _{
  ("if" | "else" | "elif" | "while" | "for" | "in" | "def" | "class"
  | "return" | "break" | "continue" | "pass" | "raise" | "try" | "except"
  | "finally" | "with" | "and" | "or" | "not" | "import" | "from" | "as"
  | "True" | "False" | "None") ~ !ident_continue
}

WHITESPACE = _{ " " | "\t" }
NEWLINE = _{ "\r\n" | "\n" }
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }
